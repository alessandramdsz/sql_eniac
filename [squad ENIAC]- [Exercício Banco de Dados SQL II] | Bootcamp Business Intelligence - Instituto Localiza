-- Pessoas que contribuiram na atividade: Alessandra, Aline, Caroline, Clara, Dayane, Elaine, Tandara

-- Ativar foreign keys (SQLite)
PRAGMA foreign_keys = ON;

-- Criar tabelas

-- Clientes
CREATE TABLE IF NOT EXISTS customers (
  customer_id INTEGER PRIMARY KEY,
  nome TEXT NOT NULL,
  email TEXT UNIQUE,
  dt_cadastro DATE
);

-- Pedidos
CREATE TABLE IF NOT EXISTS orders (
  order_id INTEGER PRIMARY KEY,
  customer_id INTEGER,
  dt_pedido DATE,
  valor_total DECIMAL(10,2),
  status TEXT CHECK(status IN ('Pendente','Pago','Cancelado')),
  FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- Produtos
CREATE TABLE IF NOT EXISTS products (
  product_id INTEGER PRIMARY KEY,
  nome TEXT NOT NULL,
  preco DECIMAL(10,2),
  categoria TEXT
);

-- Itens do Pedido
CREATE TABLE IF NOT EXISTS order_items (
  order_item_id INTEGER PRIMARY KEY,
  order_id INTEGER,
  product_id INTEGER,
  quantidade INTEGER,
  preco_unitario DECIMAL(10,2),
  FOREIGN KEY (order_id) REFERENCES orders(order_id),
  FOREIGN KEY (product_id) REFERENCES products(product_id)
);

-- Limpar tabelas para evitar duplicação
DELETE FROM order_items;
DELETE FROM orders;
DELETE FROM products;
DELETE FROM customers;

-- Inserindo os dados das tabelas

-- Clientes
INSERT INTO customers (customer_id, nome, email, dt_cadastro) VALUES
(6, 'Mariana Costa', 'mariana@gmail.com', '2024-03-12'),
(7, 'Ricardo Almeida', 'ricardo@uol.com', '2024-06-05'),
(8, 'Fernanda Lima', 'fernanda@yahoo.com', '2024-07-01'),
(9, 'Gabriel Rocha', 'gabriel@hotmail.com', '2024-08-18'),
(10, 'Juliana Mendes', 'juliana@gmail.com', '2024-09-02'),
(1, 'João Pereira', 'joao@gmail.com', '2024-01-10'),
(2, 'Ana Souza', 'ana@yahoo.com', '2024-02-15'),
(3, 'Carlos Lima', 'carlos@hotmail.com', '2024-03-05'),
(4, 'Beatriz Oliveira', 'bia@outlook.com', '2024-04-20'),
(5, 'Pedro Santos', 'pedro@gmail.com', '2024-05-01');

-- Produtos
INSERT INTO products (product_id, nome, preco, categoria) VALUES
(1, 'Notebook Lenovo', 3500.00, 'Eletrônicos'),
(2, 'Smartphone Samsung', 2500.00, 'Eletrônicos'),
(3, 'Camisa Polo', 120.00, 'Roupas'),
(4, 'Tênis Nike', 400.00, 'Roupas'),
(5, 'Livro SQL Avançado', 90.00, 'Livros'),
(6, 'Cafeteira Elétrica', 250.00, 'Casa'),
(7, 'Fone Bluetooth', 350.00, 'Eletrônicos'),
(8, 'Calça Jeans', 180.00, 'Roupas'),
(9, 'Tablet Apple iPad', 4500.00, 'Eletrônicos'),
(10, 'Monitor Dell 27"', 1800.00, 'Eletrônicos'),
(11, 'Batedeira Planetária', 900.00, 'Casa'),
(12, 'Livro Python Avançado', 110.00, 'Livros'),
(13, 'Jaqueta de Couro', 750.00, 'Roupas'),
(14, 'Tênis Adidas', 380.00, 'Roupas'),
(15, 'Smartwatch Garmin', 2200.00, 'Eletrônicos'),
(16, 'Aspirador de Pó', 600.00, 'Casa');

-- Pedidos
INSERT INTO orders (order_id, customer_id, dt_pedido, valor_total, status) VALUES
(101, 1, '2024-06-01', 3620.00, 'Pago'),
(102, 1, '2024-07-10', 120.00, 'Pago'),
(103, 2, '2024-07-15', 2500.00, 'Pago'),
(104, 2, '2024-08-20', 0.00, 'Cancelado'),
(105, 3, '2024-08-25', 490.00, 'Pago'),
(106, 3, '2024-09-05', 90.00, 'Pago'),
(107, 4, '2024-09-10', 250.00, 'Pago'),
(108, 4, '2024-09-15', 400.00, 'Pago'),
(109, 5, '2024-09-20', 3500.00, 'Pendente'),
(110, 6, '2024-06-20', 750.00, 'Pago'),
(111, 6, '2024-07-22', 900.00, 'Pago'),
(112, 7, '2024-08-05', 4500.00, 'Pago'),
(113, 7, '2024-08-25', 2200.00, 'Pago'),
(114, 8, '2024-09-01', 380.00, 'Pago'),
(115, 8, '2024-09-10', 1800.00, 'Pago'),
(116, 9, '2024-09-12', 110.00, 'Pago'),
(117, 9, '2024-09-22', 600.00, 'Pago'),
(118, 10, '2024-09-25', 0.00, 'Cancelado'),
(119, 10, '2024-09-28', 350.00, 'Pendente');

-- Itens dos Pedidos
INSERT INTO order_items (order_item_id, order_id, product_id, quantidade,
preco_unitario) VALUES
-- Pedido 101 (João)
(1001, 101, 1, 1, 3500.00),
(1002, 101, 5, 1, 120.00),
-- Pedido 102 (João)
(1003, 102, 3, 1, 120.00),
-- Pedido 103 (Ana)
(1004, 103, 2, 1, 2500.00),
-- Pedido 104 (Ana) - cancelado
(1005, 104, 8, 1, 180.00),
-- Pedido 105 (Carlos)
(1006, 105, 4, 1, 400.00),
(1007, 105, 5, 1, 90.00),
-- Pedido 106 (Carlos)
(1008, 106, 5, 1, 90.00),
-- Pedido 107 (Beatriz)
(1009, 107, 6, 1, 250.00),
-- Pedido 108 (Beatriz)
(1010, 108, 4, 1, 400.00),
-- Pedido 109 (Pedro - pendente)
(1011, 109, 1, 1, 3500.00),
-- Pedido 110 (Mariana)
(1012, 110, 13, 1, 750.00),
-- Pedido 111 (Mariana)
(1013, 111, 11, 1, 900.00),
-- Pedido 112 (Ricardo)
(1014, 112, 9, 1, 4500.00),
-- Pedido 113 (Ricardo)
(1015, 113, 15, 1, 2200.00),
-- Pedido 114 (Fernanda)
(1016, 114, 14, 1, 380.00),
-- Pedido 115 (Fernanda)
(1017, 115, 10, 1, 1800.00),
-- Pedido 116 (Gabriel)
(1018, 116, 12, 1, 110.00),
-- Pedido 117 (Gabriel)
(1019, 117, 16, 1, 600.00),
-- Pedido 118 (Juliana - cancelado)
(1020, 118, 5, 1, 90.00),
(1021, 118, 8, 1, 260.00),
-- Pedido 119 (Juliana - pendente)
(1022, 119, 7, 1, 350.00);

-- DESAFIOS ABAIXO

-- 1.1 Liste o valor médio gasto por cliente usando uma CTE

WITH total_por_cliente AS (
  SELECT 
    c.customer_id,
    c.nome,
    COALESCE(SUM(o.valor_total), 0) AS total_gasto
  FROM customers c
  LEFT JOIN orders o
    ON c.customer_id = o.customer_id
    AND o.status = 'Pago'
  GROUP BY c.customer_id, c.nome
),
media_geral AS (
  SELECT ROUND(AVG(total_gasto),2) AS valor_medio_geral
  FROM total_por_cliente
)
SELECT 
  t.nome,
  t.total_gasto,
  m.valor_medio_geral
FROM total_por_cliente t
CROSS JOIN media_geral m;

-- 1.2 CTE recursiva meses últimos 12 meses + left join

 WITH RECURSIVE months(m) AS (
  SELECT date('now','start of month','-11 months')
  UNION ALL
  SELECT date(m, '+1 month') FROM months WHERE m < date('now','start of month')
)
SELECT
  strftime('%Y-%m', m) AS ano_mes,
  COALESCE(SUM(o.valor_total), 0) AS faturamento_mes
FROM months
LEFT JOIN orders o
  ON strftime('%Y-%m', o.dt_pedido) = strftime('%Y-%m', m)
  AND o.status <> 'Cancelado'
GROUP BY ano_mes
ORDER BY ano_mes;

-- 2.1 Para cada cliente, mostre o valor do pedido e o rank dos pedidos (maior → menor)

SELECT 
  c.customer_id AS id_cliente,
  c.nome,
  o.order_id,
  o.valor_total,
DENSE_RANK() OVER (PARTITION BY c.customer_id ORDER BY o.valor_total DESC) AS rank_pedido
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.status <> 'Cancelado'
ORDER BY c.customer_id, rank_pedido;

-- 2.2 Calcule a média móvel de 3 pedidos para cada cliente

SELECT c.CUSTOMER_ID AS "Id do cliente",
       c.NOME AS "Nome do Cliente",
       o.ORDER_ID AS "Id do pedido",
       o.DT_PEDIDO AS "Data do pedido",
       o.VALOR_TOTAL AS "Valor total",
       AVG(o.VALOR_TOTAL) OVER (PARTITION BY c.CUSTOMER_ID
                                ORDER BY o.DT_PEDIDO, o.ORDER_ID
                                ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) 
                                AS "Média móvel de 3 pedidos"
FROM CUSTOMERS c
JOIN ORDERS o ON c.CUSTOMER_ID = o.CUSTOMER_ID
ORDER BY c.CUSTOMER_ID,
         o.DT_PEDIDO,
         o.ORDER_ID;

-- 2.3 Mostre o valor do primeiro e do último pedido de cada cliente usando FIRST_VALUE
e LAST_VALUE

SELECT DISTINCT
    c.customer_id,
    c.nome,
    FIRST_VALUE(o.valor_total) OVER (
        PARTITION BY c.customer_id 
        ORDER BY o.dt_pedido ASC
    ) AS primeiro_pedido,
    LAST_VALUE(o.valor_total) OVER (
        PARTITION BY c.customer_id 
        ORDER BY o.dt_pedido ASC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS ultimo_pedido
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id;

-- 3.1 Crie uma View que mostre o faturamento diário consolidado

CREATE VIEW faturamento_diario AS
SELECT dt_pedido AS data_faturamento,
       SUM(valor_total) AS faturamento_total,
       COUNT(*) AS qtd_pedidos
FROM orders
WHERE status = 'Pago'
GROUP BY dt_pedido;

-- 3.2 Crie uma Tabela temporária com os clientes que fizeram compras nos últimos 30
dias

CREATE TEMPORARY TABLE clientes_compraram_ultimos_30_dias AS
SELECT DISTINCT
    c.customer_id,
    c.nome,
    c.email,
    o.dt_pedido
FROM
    customers c
JOIN
    orders o ON c.customer_id = o.customer_id
WHERE
    o.dt_pedido >= DATE('now', '-30 days')
    AND o.status = 'Pago'; -- Filtro para considerar apenas compras "efetivas";

-- 4.1 Liste todos os produtos e indique se foram ou não vendidos (LEFT JOIN)

SELECT
  p.nome,
CASE
WHEN oi.order_item_id IS NULL THEN 'Não Vendido'
ELSE 'Vendido'
END AS status_venda
FROM products p
LEFT JOIN order_items oi
ON p.product_id = oi.product_id
GROUP BY
  p.product_id;

-- 4.2 Traga os clientes que compraram todos os produtos de uma categoria (pode usar
NOT EXISTS

SELECT c.customer_id, c.nome
FROM customers c
WHERE NOT EXISTS (
 
    SELECT 1
    FROM products p
    WHERE p.categoria = 'Roupas'
      AND NOT EXISTS (

          SELECT 1
          FROM orders o
          JOIN order_items oi ON o.order_id = oi.order_id
          WHERE o.customer_id = c.customer_id
            AND o.status = 'Pago'
            AND oi.product_id = p.product_id
          )
);

-- 4.3 Monte um relatório de clientes que compraram um produto, mas nunca outro (ex.:
compraram da categoria "Eletrônicos", mas nunca da categoria "Roupas")

WITH categorias_cliente AS (
  SELECT 
    c.customer_id,
    c.nome,
    p.categoria
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id AND o.status = 'Pago'
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  GROUP BY c.customer_id, c.nome, p.categoria
)
SELECT 
  customer_id,
  nome,
  GROUP_CONCAT(categoria) AS categorias_compradas,
  SUM(CASE WHEN categoria = 'Eletrônicos' THEN 1 ELSE 0 END) AS qtd_electronicos,
  SUM(CASE WHEN categoria = 'Roupas' THEN 1 ELSE 0 END) AS qtd_roupas
FROM categorias_cliente
GROUP BY customer_id, nome
HAVING (qtd_electronicos > 0 AND qtd_roupas = 0)
   OR (qtd_roupas > 0 AND qtd_electronicos = 0);

-- 5.1 Mostre apenas o domínio do e-mail dos clientes (parte depois do @)

SELECT
  customer_id,
  UPPER(nome) AS nome_maiusculo,
  substr(email, instr(email, '@') + 1) AS dominio_email
FROM customers;

-- 5.2 Converta o nome dos clientes para MAIÚSCULAS

SELECT 
    customer_id,
    UPPER(nome) AS nome_maiusculo,
    email,
    dt_cadastro
FROM customers; 

-- 5.3 Crie uma coluna calculada que concatene o nome do cliente com o ID do pedido
(ex.: "João - Pedido 123")

SELECT 
  c.customer_id,
  c.nome,
  o.order_id,
  c.nome || ' - Pedido ' || o.order_id AS cliente_pedido
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
ORDER BY c.nome, o.order_id;

-- 6.1 Mostrar apenas o ano da data de cadastro dos clientes

SELECT 
    customer_id,
    nome,
    dt_cadastro,
    strftime('%Y', dt_cadastro) AS ano_cadastro
FROM customers
ORDER BY ano_cadastro;

-- 6.2 Calcular quantos dias se passaram desde o pedido

SELECT 
  order_id,
  customer_id,
  dt_pedido,
  ROUND(julianday('now') - julianday(dt_pedido)) AS dias_desde_pedido
FROM orders
ORDER BY dias_desde_pedido DESC;

-- 6.3 Adicionar 7 dias à data do pedido (ex.: prazo de entrega)

SELECT 
  order_id,
  customer_id,
  dt_pedido,
  DATE(dt_pedido, '+7 days') AS prazo_entrega
FROM orders
ORDER BY dt_pedido;

-- 7.1 Crie um índice em orders (customer_id, dt_pedido) e explique quando ele será
usado

CREATE INDEX idx_orders_customer_date
ON orders (customer_id, dt_pedido);

-- Este índice será usado sempre que precisarmos fazer consultas que filtram ou ordenam pela combinação customer_id e dt_pedido, como:
-- Filtro por cliente e período

SELECT * FROM orders
WHERE customer_id = 3 AND dt_pedido >= '2024-07-01';

-- Junção com clientes

SELECT c.nome, o.valor_total
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id;

-- 7.2 Compare uma query que faz JOIN com EXISTS E analise qual é mais performática

SELECT 
    c.customer_id,
    c.nome
FROM 
    customers c
WHERE 
    EXISTS (
        SELECT 1
        FROM orders o
        WHERE o.customer_id = c.customer_id
    );

 -- 7.3 Identifique consultas que podem ser reescritas usando CTE materializada para
melhorar a performance

WITH pedidos_por_cliente AS (
    SELECT 
        customer_id,
        SUM(valor_total) AS total_gasto,
        COUNT(*) AS qtd_pedidos,
        AVG(valor_total) AS ticket_medio
    FROM orders
    WHERE status = 'Pago'
    GROUP BY customer_id
)
SELECT 
    c.customer_id,
    c.nome,
    COALESCE(p.total_gasto, 0) AS total_gasto,
    COALESCE(p.qtd_pedidos, 0) AS qtd_pedidos,
    ROUND(COALESCE(p.ticket_medio, 0), 2) AS ticket_medio
FROM customers c
LEFT JOIN pedidos_por_cliente p 
    ON c.customer_id = p.customer_id
ORDER BY total_gasto DESC;

 -- 8.1 Use CASE WHEN para classificar pedidos em: "Baixo" (<100), "Médio" (100-500),
"Alto" (>500)

SELECT ORDER_ID AS "Id do pedido",
       VALOR_TOTAL AS "Valor total",
    CASE
        WHEN VALOR_TOTAL < 100 THEN 'Baixo'
        WHEN VALOR_TOTAL >= 100 AND valor_total <= 500 THEN 'Médio'
        WHEN VALOR_TOTAL > 500 THEN 'Alto'
    END AS "Classificação do valor"
FROM ORDERS
ORDER BY VALOR_TOTAL DESC;

-- 8.2 Crie uma coluna calculada que mostre se o cliente está Ativo (pedido nos últimos 6
meses) ou Inativo

 SELECT 
 c.customer_id,
 c.nome,
 MAX(o.dt_pedido) AS ultima_compra,
 CASE 
   WHEN julianday('now') - julianday(MAX(o.dt_pedido)) <= 180 THEN 'Ativo'
   ELSE 'Inativo'
   END AS status_cliente
FROM customers c
LEFT JOIN orders o
  ON c.customer_id = o.customer_id
  AND o.status = 'Pago'
GROUP BY c.customer_id, c.nome;

-- 8.3 Em um relatório de pedidos, mostre NULL como "Sem valor informado".

SELECT 
  o.order_id,
  c.nome AS cliente,
  COALESCE(CAST(o.dt_pedido AS TEXT), 'Sem valor informado') AS data_pedido,
  COALESCE(CAST(o.valor_total AS TEXT), 'Sem valor informado') AS valor_total,
  COALESCE(o.status, 'Sem valor informado') AS status
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id;
